{"version":3,"sources":["../../src/resource-cache/resource-cache.ts"],"sourcesContent":["import * as SecureStore from 'expo-secure-store';\n\nimport type { IStorage } from '../provider/singleton/types';\n\nconst CLERK_DEFAULT_CHUNK_SIZE = 1024;\n\ntype KeyValuePair = {\n  key: string;\n  value: string;\n};\n\ntype Metadata = {\n  totalChunks: number;\n};\n\n/**\n * Creates a store based on expo-secure-store, that handles the 2048 size limit on values.\n *\n * The store uses a queue to manage multiple save requests and two slots (A and B) to store the key-value pairs.\n * The function alternates between the two slots to save the key-value pairs and splits the value into chunks to save them.\n * The two slots are used to handle corrupted data or incomplete saves.\n *\n * The keys used are the following:\n * - key-latest -> 'A'/'B'\n * - key-{A/B}-metadata -> Metadata\n * - key-{A/B}-chunk-{i} -> data chunk\n * - key-{A/B}-complete -> 'true'/'false'\n *\n **/\nexport const createResourceCacheStore = (): IStorage => {\n  let queue: KeyValuePair[] = [];\n  let isProcessing = false;\n\n  const secureStoreOpts: SecureStore.SecureStoreOptions = {\n    /**\n     * The data in the keychain item cannot be accessed after a restart until the\n     * device has been unlocked once by the user.\n     *\n     * This may be useful if you need to access the item when the phone is locked.\n     */\n    keychainAccessible: SecureStore.AFTER_FIRST_UNLOCK,\n  };\n  const setItem = (key: string, value: string) => SecureStore.setItemAsync(key, value, secureStoreOpts);\n  const getItem = (key: string) => SecureStore.getItemAsync(key, secureStoreOpts);\n  const deleteItem = (key: string) => SecureStore.deleteItemAsync(key, secureStoreOpts);\n\n  const set = (key: string, value: string): Promise<void> => {\n    queue.push({ key, value });\n    void processQueue();\n    return Promise.resolve();\n  };\n\n  const processQueue = async (): Promise<void> => {\n    if (isProcessing || queue.length === 0) {\n      return;\n    }\n\n    isProcessing = true;\n    const item = queue.pop();\n    if (!item) {\n      isProcessing = false;\n      return;\n    }\n    queue = [];\n\n    try {\n      const latestKey = `${item.key}-latest`;\n      const latestSlot = (await getItem(latestKey)) || 'A';\n      const targetSlot = latestSlot === 'A' ? 'B' : 'A';\n\n      await performSet(item.key, item.value, targetSlot);\n      await setItem(latestKey, targetSlot);\n      isProcessing = false;\n    } catch (err) {\n      isProcessing = false;\n      throw err;\n    } finally {\n      void processQueue();\n    }\n  };\n\n  const performSet = async (key: string, value: string, slot: string): Promise<void> => {\n    const slotKey = `${key}-${slot}`;\n    const chunks = splitIntoChunks(value);\n    const metadataKey = `${slotKey}-metadata`;\n\n    // before saving new chunks, mark the slot as incomplete\n    await setItem(`${slotKey}-complete`, 'false');\n\n    // save the chunks\n    for (let i = 0; i < chunks.length; i++) {\n      const chunkKey = `${slotKey}-chunk-${i}`;\n      await setItem(chunkKey, chunks[i]);\n    }\n\n    // delete any extra chunks from previous saved value\n    const oldMetadataString = await getItem(metadataKey);\n    if (oldMetadataString) {\n      const oldMetadata: Metadata = JSON.parse(oldMetadataString);\n      for (let i = chunks.length; i < oldMetadata.totalChunks; i++) {\n        const chunkKey = `${slotKey}-chunk-${i}`;\n        await deleteItem(chunkKey);\n      }\n    }\n\n    // save metadata\n    const metadata: Metadata = { totalChunks: chunks.length };\n    await setItem(metadataKey, JSON.stringify(metadata));\n\n    // mark the slot as complete\n    await setItem(`${slotKey}-complete`, 'true');\n  };\n\n  const get = async (key: string): Promise<string | null> => {\n    const latestKey = `${key}-latest`;\n    const latestSlot = (await getItem(latestKey)) || 'A';\n\n    const latestValue = await getSlot(`${key}-${latestSlot}`);\n    if (latestValue !== null) {\n      return latestValue;\n    }\n\n    const fallbackSlot = latestSlot === 'A' ? 'B' : 'A';\n    return await getSlot(`${key}-${fallbackSlot}`);\n  };\n\n  const getSlot = async (slotKey: string): Promise<string | null> => {\n    const metadataKey = `${slotKey}-metadata`;\n    const isComplete = await getItem(`${slotKey}-complete`);\n    if (isComplete !== 'true') {\n      return null;\n    }\n\n    const metadataString = await getItem(metadataKey);\n    if (!metadataString) {\n      return null;\n    }\n    const metadata: Metadata = JSON.parse(metadataString);\n    if (!metadata) {\n      return null;\n    }\n\n    const chunks = [];\n    for (let i = 0; i < metadata.totalChunks; i++) {\n      const chunkKey = `${slotKey}-chunk-${i}`;\n      const chunk = await getItem(chunkKey);\n      if (!chunk) {\n        return null;\n      }\n      chunks.push(chunk);\n    }\n\n    return chunks.join('');\n  };\n\n  return {\n    set,\n    get,\n  };\n};\n\nconst splitIntoChunks = (value: string, chunkSize = CLERK_DEFAULT_CHUNK_SIZE): string[] => {\n  // Array.from is used to handle unicode characters correctly\n  const characters = Array.from(value);\n\n  const chunks: string[] = [];\n  for (let i = 0; i < characters.length; i += chunkSize) {\n    chunks.push(characters.slice(i, i + chunkSize).join(''));\n  }\n  return chunks;\n};\n"],"mappings":"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","names":[]}